#include <iostream>
#include <cstdio>

struct Data
{
	int age; //나이
	char name[100]; //이름
	int balance; //지갑 속의 용돈
};

struct Test
{
	Test(int a) {}
};

void Print(Data user)
{
	std::cout << user.age << ", " << user.name << ", 잔액 : " << user.balance << std::endl;
}

int main()
{
	// 1. 대입 연산자를 사용하여 리터럴을 대입하는 방식으로 변수의 생성과 초기화는 구조체나 클래스 타입의 경우 허용하지 않는다.
	// 컴파일 시 int 타입에서 구조체로 타입을 변환시킬 수 없다는 에러가 발생한다.
	// Data user01 = 21;
	// 이것은 내 생각 -> 위의 구절은 인자가 하나인 생성자를 염두에 두지 않고 선생님께서 쓰신 말같다.
	Test test = 1;

	// 2. 구조체 내 변수의 순서에 맞추어 리터럴을 함수의 인수로 사용하여 변수를 초기화한다면,
	// 다음과 같은 에러가 발생한다. 이 문제의 해결 방안은 구조체의 생성자를 만들어 제공하면 된다.
	// Data user02(33, "이순신", 200000);

	// 3. 그러나 아래와 같이 중괄호를 사용한다면, 초기화가 혀용된다.
	// 입력된 인수는 순서적으로 멤버 변수에 할당된다.
	Data user03{ 53, "강감찬", 20000 }; // -std=c+11 이후부터 사용이 가능하다.
	Print(user03);

	// 4. 무명 변수를 만들어 무명 변수의 값을 변수에 대입시켜 초기화한다. 앞에서 보았던 2. 와 동일한 
	// 에러가 발생한다. 이 문제 역시 생성자를 만들어주면 해결된다.
	// Data user04 = Data(45, "이성계", 304040);

	// 5. 아래처럼 함수 호출 연산자와 함께 변수를 생성한다면, 컴파일 에러가 발생한다.
	// 무명변수는 허용되지만 안정성의 이유로 아래와 같이 직접 변수를 생성하는 방식은 ISO에서 금지하는 방식이다.
	// Data user05();

	// 6. 아래와 같이 Data 타입의 무명 변수를 생성하고 변수에 대입한다면, 변수가 생성되는
	// 동시에 모든 멤버 변수는 타입에 따라 초기화된다.
	Data user06 = Data();
	Print(user06);

	// 7. 구조체와 클래스는 다음과 같이 나열된 값으로 변수에 순서대로 할당하여 초기화시킬 수 있다.
	// 이 방식은 C 언어에서 유래된 방식이다.
	Data user07 = { 21, "홍길동", 10000 };
	Print(user07);

	// 8. 초기화없이 구조체의 변수를 선언한다면 멤버 변수에 알 수 없는 값이 들어간다.
	Data user08;
	Print(user08);

	// new 라는 키워드를 사용하여 메모리 저장소를 생성하여 변수에 할당한다.
	// 이 경우 역시 멤버 변수에 알 수 없는 값이 들어간다.
	Data* user_08 = new Data;
	Print(*user_08);

	// 9. new 지정자와 함께 아래처럼 변수를 생성하면 모두 자동으로 초기화된다.
	Data* user09 = new Data();
	Print(*user09);
}
# 멀티스레드와 비동기 프로그래밍 14

- 스레드의 생성과 종료
- 스레드-안전 함수
- 원자성 변수 (atomic variable)
- 뮤텍스 (Mutex)
- 조건 변수
- 비동기 스레드 프로그래밍
- 마무리

<br>

프로그램은 프로그램 언어로 제작된 실행 가능한 파일을 이야기한다. 하나의 운영체제에서 프로그램은 하나 이상으로 실행이 가능하기 때문에 실행되는 개별 프로그램을 프로세스(Process)라고 부른다.

<br>

프로세스는 운영체제가 프로그램을 실행시키는 작업단위가 되며, 같은 프로세스라 하더라도 실행되는 환경이나 조건에 따라 서로 다른 기능을 제공한다.

<br>

반면 스레드는 프로세스 내부에 존재하는 실행 경로를 의미한다. (실행 흐름)

스레드는 프로세스의 메모리를 공유한다. (스택, 레지스터 제외)

<br>

멀티 태스크 작업에서 프로세스의 문제점

1. 프로세스의 복사는 프로세스의 생성 시간과 함께 리소스의 추가 소모라는 비효율이 따른다.
2. 프로세스가 사용하는 메모리는 시스템의 보호를 받고 있어 원칙적으로 부모 프로세스라 할지라도 자식 프로세스 내 메모리 영역을 공유할 수 없도록 되어 있다. 만약 프로세스간에 필요한 데이터를 주고 받으려면, IPC 통신이나 공유 메모리를 사용해야 한다.

<br>

스레드는 하나의 작업을 위해 동시에 실행되는 병렬 방식으로 작업이 이루어진다.

스레드는 독립적인 스택에 지역 변수를 저장할 수 있다.

스택 내 저장하는 데이터가 넘쳐나 오버플로우가 발생할 때 스레드 스택의 확장이 가능하도록 스택의 마지막 위치에 1 페이지 (약 4096 바이트의 크기) 정도의 공간을 추가로 확보한다. 이 공간을 레드 존(red zone) 이라 부른다.

<br>

STL 라이브러리에서 제공하는 스레드와 관련된 기능은 크게 다음과 같이 4가지 타입의 카테고리로 나눌 수 있다.

1. 스레드 관리(Thread Management) : 스레드 객체를 생성하고 실행시키며 또한 종료시키는 작업을 수행한다.
2. 뮤텍스(Mutexes) : 뮤텍스는 멀티 스레드 환경에서 리소스의 무분별한 사용을 제어하는 목적으로 스레드와의 동기화 기능을 제공한다. 뮤텍스 클래스는 객체를 생성하여 잠금을 걸고 푸는 기능을 제공한다.
3. 조견 변수(Condition Varialbes) : 조건 변수가 가지는 값에 따라 스레드의 작업이 실행되거나 대기 하는 기능을 제공한다.
4. 비동기 작업(Asynchronous Task) : 스레드 작업이 하나가 끝나면 작업 결과가 자연스럽게 다른 하나의 스레드로 넘어가 실행하는 기능을 제공한다.

<br><br>

### 14 - 01 스레드의 생성과 종료

메인 스레드는 프로세스의 생성과 동시에 자동으로 생성되고 실행되는 첫 번째 스레드이다. (main 함수라 생각하면 될 듯)

이후 생성되는 스레드는 clone() 이란 시스템콜을 호출하여 메인 스레드를 복사하여 일반 스레드로 만드는 작업 과정을 거친다.

<br><br>

**스레드 객체는 다음과 같은 생성자를 사용하여 생성된다.**

```cpp
template<class Function, class... Args>
explicit thread(Function&& f, Args&&... args) : <thread>
```

첫 번째 인수는 함수 (람다, 함수 객체, 포인터 등…)

두 번째 가변 인수는 첫 번째 함수에서 사용하는 인수

<br>

```cpp
thread(thread&& other) : <thread>
```

이동 생성자로 무명 스레드를 사용하여 스레드 객체를 생성한다. 스레드 객체는 생성과 동시에 스케쥴이라고 부르는 시스템의 작업 계획에 따라 실행된다.

<br>

```cpp
thread() : <thread>
```

디폴트 생성자 →  스레드는 함수와 함께 사용해야 하기 때문에 디폴트 생성자는 스레드 객체가 생성되더라도 실행되지 않는다.

<br>

무명 스레드 객체를 생성하여 이동 대입해야 한다.

```cpp
std::thread Thread;
Thread = std::thread(InThread, "Thread2");
```

<br>

스레드 생성자에서 중요한 점은 **복사 생성자는 삭제**되었다는 점이다.

<br><br>

**std::this_thread namespace 안의 전역 함수들**

```cpp
thread::id get_id() noexcept
```

운영체제가 쓰레드에 부여한 id 반환

<br>

```cpp
void yield() noexcept
```

스레드가 실행될 수 있는 권한을 다른 스레드에 양보하고 자기 자신은 다음 순서를 기다린다.

<br>

```cpp
template <class Clock, class Duration>
void sleep_untill(const std::chrono::time_point<Cock, Duration>& abs_time);
```

매개변수로 주어진 시간까지 잠시 대기한다. 매개변수는 미래의 시간을 가리킨다.

<br>

```cpp
template <class Rep, class Period>
void sleep_for(const std::chrono::duration<Rep,Period>& rel_time);;
```

인수로 주어진 시간동안 잠시 대기한다.

<br><br>

**프로그램의 종료 조건**

1. 메인 스레드에서 실행되는 main() 함수 (정확히 이야기하여 메인 스레드) 의 실행이 완료되어 프로그램의 제어를 운영체제에 반환할 때
2. 메인 스레드나 일반 스레드에서 exit() 함수나 terminate() 함수를 호출할 때
3. 예외나 에러가 발생했을 때

<br>

프로그램이 정상적으로 실행되려면, 모든 스레드의 작업이 완료되고 난 다음에 마지막으로 메인 스레드가 종료되어야 한다. 즉 다른 말로 이야기하여 스레드 역시 종속 관계가 존재하며, 일반 스레드를 실행시킨 메인 스레드는 의도적이든 아니든 가장 늦게 작업이 종료되어야 한다.

<br>

- join()
    - 스레드가 종료될 때까지 join() 함수를 호출한 스레드의 작업이 지연된다.
    - main 에서 thread.join()을 호출할 시 thread의 작업이 끝날 때까지 main 이 종료되지 않는다.
- detach()
    - 메인 스레드와 일반 스레드를 분리시키는 기능을 제공한다.
    - 분리된 스레드 객체는 독자 작업을 수행하지만 만약 메인 스레드가 종료된다면, 일반 스레드 역시 에러 발생 없이 그대로 종료된다.

<br>

join(), detach() 함수를 호출하지 않는다면, 스레드의 작업이 종료되더라도 운영체제는 해당 스레드가 사용한 리소스를 재활용하거나 해제시키지 않으며, 또한 프로그램이 종료될 때 비정상적으로 에러를 발생시키고 종료된다.

<br><br>

**join() 함수와 detach() 함수를 사용할 때 주의해야 할 점**

- 자기 자신의 스레드에 대해 join() 함수를 호출하지 않아야 한다. 만약 join() 함수를 호출한다면 자기가 자신의 종료를 대기하게 되므로 영원히 대기하게 된다.
- detach() 함수를 호출하여 분리된 스레드에 대해 join() 함수를 호출하여 다시 묶으려 한다면, 에러가 발생한다.

<br><br>

### 14-02 스레드-안전 함수

스레드-안전 함수(Thread-Safe Function)는 다수의 스레드(멀티 스레드)에 의해 함수가 호출되더라도 프로그램 내부에 사용하는 공유 변수들을 순차적(Serial)으로 참조하는 함수를 말한다.

<br>

두 개 이상의 스레드가 동시에 같은 전역 변수(또는 정적 변수)로부터 데이터를 읽거나 또는 데이터를 쓴다면, 스레드 내에서 실행되는 함수들간의 경쟁 조건(race condition)이 발생한다.

<br>

경쟁 조건은 한마디로 **이벤트가 발생하는 시간 차이에 의해 프로그램의 정확성(Correctness)**에 영향을 주는 결함을 말한다.

<br>

예시) 두 개 이상의 스레드 가운데 하나 이상의 스레드가 데이터를 수정한다면, 다른 스레드는 데이터를 읽는 순서에 따라 오래된 데이터를 읽거나 수정된 데이터를 읽을 수 있다.

<br>

경쟁 조건이 유발하는 문제의 심각성을 고려하여 다음과 같이 두가지 형태로 나눌 수 있다.

- 심각한 경쟁 조건 : 변수를 참조하는 순서에 따라 결함이 발생하는 경쟁 조건
- 심각하지 않은 경쟁 조건 : 변수를 참조하는 순서가 바뀌더라도 결과에 영향을 주지 않는 경쟁 조건

<br>

스레드-안전 함수는 경쟁 조건이 발생하더라도 공유 변수들을 순차적으로 참조하고 업데이트시키는 함수

전역 변수에 순차적으로 접근시키는 방법은 네 가지 방법이 있다.

1. 스레드 생성과 동시에 join() 함수를 호출하여 공유 변수의 접근을 순차적으로 만든다.
2. 전역 변수를 스레드별로 독립적으로 사용할 수 있는 **스레드 지역 변수(Thread-Local Storage)**로 만든다.
3. 변수를 **원자성 변수(Atomic Variable)**로 만든다. 단계별 작업 수행에 있어 방해를 받지 않도록 만든다.
4. **뮤텍스(Mutex)**라고 하는 특수한 장치를 사용하여 인위적으로 공유 변수의 접근을 순차적으로 만든다.

<br>

성능 기준 2 > 3 > 4 > 1 / 1은 원칙적으로 멀티 태스킹이라 할 수 없는 방법

<br>

문제를 엄밀히 살펴보면, 경쟁 조건은 스레드에서 사용하는 함수들이 전역 변수나 정적 변수를 경쟁적으로 사용하기 때문에 발생하는 문제이다.

<br>

스레드는 생성 시점에 스레드 스택과 함께 **스레드 컨트롤 블록(TCB)**이라고 하는 메모리 공간을 하나씩 할당받는다. 스레드 지역 변수는 이 공간을 이용한다. 따라서 스레드가 생성하는 시점에 개별 스레드마다 독립적으로 사용할 수 있는 **스레드 지역 변수**를 만들어 함수들이 공유하는 방법이 있다.

<br><br>

### 14-03 원자성 변수(atomic variable)

**컴퓨터 작업은 다음과 같은 단계로 이루어진다.**

1. 메모리 내 존재하는 변수의 데이터를 읽어 CPU 캐시로 이동하여 보관한다.
2. 캐시 내 데이터는 다시 레지스터로 이동하여 계산 작업을 수행한다.
3. 작업 결과는 다시 캐시에 넣는다.
4. 필요하다면 다시 캐시로부터 데이터를 읽어 레지스터에 넣어 작업을 수행한다.
5. 캐시의 데이터가 더 이상 사용하지 않거나 또는 일정 시간이 경과된다면 캐시로부터 메모리 저장소로 데이터의 이동이 발생하게 된다.

<br>

여기서 문제는 “변수는 메모리에 저장되어 있지만 스레드가 작업하는 과정에서 일정 시간동안 메모리가 아닌 캐시 내 데이터를 사용하여 작업이 이루어진다는 사실이다” 즉, 서로 다른 스레드가 작업을 위해 같은 변수의 데이터를 저마다 다른 캐시 내 데이터로 저장하여 사용한다면 실제 변수의 데이터는 왜곡될 수 있는 위험이 공존한다.

<br>

이러한 모든 작업은 다른 스레드 작업의 간섭없이 단일 작업으로 이루어져야 하며, 이를 원자성이라 한다. C+ 11 때부터 atomic 타입을 사용할 수 있게 되었다.

<br>

atomic 타입은 3단계로 이루어지는 RMW(Read-Modify-Write) 작업을 단일 원자성 동작으로 만들어주는 특수 어셈블리 기계어를 사용한다.

1. R : 메모리 변수의 데이터를 레지스터로 읽어 들인다.
2. M : 레지스터의 데이터를 수정한다.
3. W : 레지스터의 데이터를 메모리 변수에 다시 넣는다.

<br>

atomic 구조체의 선언은 다음과 같다.

```cpp
template<class T>
struct atomic : <atomic>

template<class T>
struct atomic<T*> : <atomic>

template<class T>
struct atomic<std::shared_ptr<U>> : <atomic>

template<class T>
struct atomic<std::weak_ptr<U>> : <atomic>
```

<br>

제공하는 함수는 다음과 같다.

```cpp
template<class T>
T load(memory_order sync = memory_order_seq_cst) const volatile noexcept : <atomic>
// 원자성 변수로부터 데이터를 읽는다.

void store(T val, memory_order sync = memory_order_seq_cst) volatile noexcept
// 원자성 변수에 데이터를 입력한다.

// fetch_add, fetch_sub
// 가감 함수
```

<br>

**메모리 작업 순서**

- 메모리 작업 순서를 나타내는 memory_order 타입은 열거형 타입으로 다음과 같은 의미를 갖는다.
    - memory_order_relaxed
        - 원자성 작업과 관련하여 전적으로 컴파일러와 하드웨어에 의존하며 별도 작업 순서에 관여하지 않는다.
    - memory_order_acquire : load() 함수에서만 사용 가능
    - memory_order_release : store() 함수와 함께 사용
        - 읽기 작업과 쓰기 작업에 충돌이 발생한다면, 읽기 작업 이전에 먼저 쓰기 작업을 수행함을 의미한다.
    - memory_order_consume
        - memory_order_acquire 과 유사한 작업을 수행
        - 읽기와 쓰기 작업이 없다면, 캐시 작업도 허용됨을 뜻한다.
    - memory_order_seq_cst
        - 단계별 연속 작업(sequentially consistent) 또는 다른 말로 RMW의 단일 작업을 수행한다.

<br>

### 14 - 04 뮤텍스(MUTEX)

두 개의 스레드가 병렬로 작업이 이루어져 위험한 프로그램 영역을 임계 구역(Critical Section) 또는 공유 변수 영역이라 한다. 임계 구역은 두 개 이상의 스레드가 동시에 접근해서는 안 되는 프로그램 내 작업 영역을 말한다.

<br>

스레드에서 실행되는 함수가 임계 구역에 진입하려면, 뮤텍스와 같은 특수 장치를 사용하여 시스템에 진입 허가를 요청해야 한다.

- 진입 허가를 요청하는 문장이나 프로그램 코드가 존재하는 영역을 입장 구역(Entry Section)이라고 한다.
- 다른 스레드에 임계 구역을 나간다는 사실을 알리는 문장이나 프로그램 코드가 존재하는 영역을 퇴장 구역(Exit Section)이라 한다.

<br>

**뮤텍스의 3가지 매커니즘**

1. 원자성(Atomicity)
    - 뮤텍스에 대한 잠금을 설정하고 해제할 때 원자적으로 작업이 이루어진다.
2. 단일점(Singularity)
    - 만약 하나의 스레드에 의해 뮤텍스 잠금을 설정하였다면, 해당 스레드에 의해 뮤텍스 잠금이 해제되기 전까지 다른 스레드가 뮤텍스 잠금을 설정할 수 없으며, 또한 잠금을 해제시킬 수 없다.
3. 대기(Non-Busy Wait)
    - 스레드가 뮤텍스 잠금을 설정하기 위해 대기 중에 있다면, CPU로부터 어떠한 작업 계획(Scheduling)도 받지 않는 상태가 된다.

<br>

**뮤텍스 사용**

```cpp
#include <mutex>

std::mutex mtx;

void lock() // 뮤텍스에 대한 잠금 설정
void unlock() // 뮤텍스의 잠금을 해제
bool try_lock() // lock과 유사, 뮤텍스의 잠금이 설정되어 있다면 false 반환 -> 기다리지 않음

mtx.lock();
mtx.unlock();
mtx.try_lock();
```

뮤텍스는 가능한 적은 범위의 임계 영역을 설정하여 작업을 수행하는 것이 좋다. <br>
하나의 문장이 임계 역역이 되면 뮤텍스보다 원자성 변수를 사용하는 것이 훨씬 더 효율이 좋다.

<br>

**다양한 뮤텍스**

```cpp
// 이미 잠금을 설정한 스레드가 무한 반복하여 잠금을 재설정시킬 수 있음
// 잠금 해제는 잠금을 설정한 횟수만큼 해제 시켜주어야 함
class recursive_mutex

// 뮤텍스에 대한 잠금을 설정할 때 시간적인 조건을 줄 수 있도록 
// try_lock_for(), try_lock_until() 함수같은걸 제공함
class timed_mutex

// recursive_mutex, timed_mutex 클래스의 두 가지 기능을 모두 가지고 있는 클래스
class recursive_timed_mutex
```

<br>

```cpp
template <class Mutex> class lock_guard;
```

- 일반적으로  뮤텍스에 대한 lock() 함수를 사용하여 잠금을 설정하면, unlock() 함수를  사용하여 뮤텍스의 잠금을 해제시켜 주어야 한다.
- 그러나 lock_guard 클래스 템플릿을 사용한다면, 객체 생성 시 잠금이 설정되고 프로그램 제어가 뮤텍스의 적용 범위를 벗어난다면 자동으로 소멸자가 호출되면서 뮤텍스 잠금을 해제하게 된다.
- 스마트 뮤텍스라 생각하면 찰떡일듯!

```cpp
int main()
{
	std::mutex Lock;
	
	std::thread Th1([&] ()
		{
			for(int i = 0; i < 5; ++i)
			{
				// guard 변수의 선언과 동시에 뮤텍스 잠금을 설정한다.
				std::lock_guard<std::mutex> guard(Lock);
				std::cout << i << " ";
			} // 뮤텍스 잠금이 해제
			std::cout << '\n';
		});

}
```

<br>

mutex, lock_guard, shared_mutex 클래스가 자주 쓰인다. <br>

읽기 작업은 변수나 리소스의 상태를 변경시키지 않는다. 따라서 다수의 쓰레드가 동시에 읽기 작업을 수행하더라도 동기화에 문제가 생기지 않는다. 반면에 쓰기 작업은 동기화에 위험이 따른다. 따라서 하나의 쓰레드에서 쓰기 작업을 수행하는 동안에는 다른 쓰레드의 읽기 작업과 쓰기 작업을 허용하지 않는다. 즉, 쓰기 작업은 하나의 쓰레드만 접근이 가능하다.

<br>

**shared_mutex**

1. shared_mutex 클래스에서 제공하는 배타적 잠금 함수와 공유 잠금 함수를 사용한다.
    - lock_shared(), try_lock_shared() 함수를 사용하여 읽는 작업을 수행하는 스레드의 접근을 허용한다.
    - 잠금을 해제시키기 위해 각각 unlock() 함수와 unlock_shared() 함수를 호출한다.
2. shared_lock 클래스 템플릿과 unique_lock 클래스 템플릿과 같은 래퍼 클래스를 함께 사용한다.
    - shared_lock 클래스 템플릿은 (shared_mutex 클래스만 받는다.) 다수의 스레드와 공유하는 기능을 제공한다.
    - unique_lock 클래스 템플릿은 shared_mutex, mutex 클래스와 함께 사용되며 뮤텍스의 배타적 잠금 기능을 제공한다.

shared_lock, unique_lock 클래스 템플릿은 lock_guard 클래스 템플릿과 같이 객체 생성 시 자동으로 잠금이 걸리고 또한 객체 소멸 시 잠금이 풀리는 기능을 제공한다. 그러나 shared_lock, unique_lock 은 별도로 lock() 함수와 unlock() 함수를 제공한다.

<br>

### 14 - 05 조건 변수

독립적으로 실행되는 쓰레드라 하더라도 경우에 따라 다른 쓰레드에 전달할 정보가 있기 마련이다. 전달하는 방법은 여러 개가 존재하지만 그 중에 하나가 조건 변수(Conditional Variable) 이다.

<br>

조건 변수는 형광등 스위치의 ON, Off 처럼 쓰레드의 작업을 대기시키는 기능과 쓰레드의 작업을 개시하는 기능을 수행하는 변수이다.

<br>

조건 변수는 단지 변수를 통해 신호를 주고 받는 기능만을 제공할 뿐 자체 기능이 없다. 따라서 다수의 쓰레드에 의해 실행되는 작업의 안전성을 보장하기 위해 별도 뮤텍스를 사용한다.

<br>

조견 변수는 쓰레드를 모두 대기 상태로 만들고 동시에 공동 경쟁을 수행하는 것이다.

<br>

조건 변수에서 가장 중요한 함수는 wait() 함수와 notify_all() 함수이다.

```cpp
void wait(std::unique_lock<std::mutex>& lock)

다른 쓰레드로부터 신호를 받을 때까지 대기하는 기능을 제공한다.
wait() 함수를 호출하기 전에 먼저 뮤텍스의 잠금을 설정해야 한다.

wait() 함수의 내부 동작
1. 인수로 제공하는 뮤텍스의 잠금을 해제시킨다.
2. 조건 변수의 신호를 받을 때까지 대기한다. void notify_all() 함수는 조건 변수의
	 신호를 기다리는 wait() 함수에 신호를 전송한다.
3. 조건 변수의 신호를 받으면, 뮤텍스의 잠금을 설정하고 작업을 수행한다.
```

<br>

조견 변수의 신호를 받는다 하더라도 다른 쓰레드에 의해 뮤텍스의 잠금이 설정되어 있으면 해제될 때까지 다시 대기하게 된다. 뮤텍스의 잠금은 조건 변수의 신호를 보내는 쓰레드가 자신의 작업을 위해 실행한다.

<br>

조건 변수의 신호를 대기하는 다수의 쓰레드들이 존재한다면, 운영체제는 스케쥴링에 따라 쓰레드들 가운데 어느 하나의 쓰레드를 선택하여 조건 변수의 신호를 전달한다. 그리고 신호를 받지 못한 나머지 쓰레드들은 계속 대기한다.

<br>

### 14 - 06 비동기 스레드 프로그래밍

쓰레드가 조건 변수의 신호가 아닌 실제 데이터를 주고 받으려면 조금 더 복잡한 작업을 수행해야 한다.

<br>

**async() 함수**

포인터를 STL 라이브러리에서 제공하는 future 클래스와 async() 함수를 사용해 대체할 수 있다.

async() 함수는 스레드의 함수를 실행시키는 역할과 함께 future 객체를 생성하여 반환하는 역할을 수행한다. future 객체는 스레드에서 실행되는 함수가 반환하는 데이터를 받아 get() 함수를 통해 전달하는 역할을 수행한다.

<br>

**future 클래스 템플릿**

- template<class T> class future
- template<class T> class future<T&>
- template<>              class future<void>

future 클래스의 주요 특징 가운데 하나는 “객체를 생성시키는 생성자를 제공하지 않는다”는 점이다.

<br>

비동기 스레드 작업을 목적으로 async() 함수를 사용한다면, 반드시 생성한 future 객체를 받아서 get() 함수 또는 wait() 함수를 호출해 주어야 한다.

<br>

**std::launch 열거형**

- std::launch::async : 생성과 동시에 작업을 수행한다.
- std::launch::deferred : 작업 실행은 future 클래스가 제공하는 get(), wait() 함수가 호출될 때까지 지연한다. 만약 get(), wait() 함수가 없다면 영원히 실행되지 못하며, 지연이 발생하게 되므로 전체적인 성능에 있어서도 영향을 받게 된다.

별도로 std::launch 열거형 타입을 사용하지 않는다면, 컴파일러는 디폴트로 std::launch::deferred 로 설정한다.

<br>

- wait() : future 객체 내 스레드에서 실행되는 함수가 완료될 때까지 기다리는 기능을 수행한다.
- get() : 스레드로 실행되는 함수가 반환하는 데이터를 전달하는 기능을 수행한다. 만약 함수의 실행이 종료되지 않았다면, 종료되어 반환받을 수 있을 때까지 기다리게 된다.

<br>

async() 함수가 반환하는 future 객체는 작업 완료 후 데이터의 반환을 받기 위해 future 객체가 존재하는 스레드와 future 객체가 호출한 스레드가 모두 공유하는 작업 공간이 필요하다. 그로 인해 공유하는 작업 공간이 확보될 때까지 async() 함수는 작업 결과의 반환을 유보한다. 따라서 작업의 지연 시간이 발생할 수 있다.

<br>

**promise 클래스 템플릿**

promise 객체는 작업 결과를 가지고 있는 future 객체를 생성하여 반환한다. 그리고 작업 결과는 스레드가 완료될 때 호출하는 set_value() 함수를 통해 전달받는다. 다시 이야기 하여 async() 함수가 아닌 promise 객체를 사용한다면, 개별 작업이 이루어진 스레드로부터 작업 결과를 future 객체를 통해 1 : m으로 전달받게 된다.

<br>

**packaged_task 클래스 템플릿**

packaged_task 클래스 템플릿은 내부에 promise 객체를 가지고 있다. 또한 동시에 packaged_task 클래스 템플릿의 생성자에 제공하는 인수는 다음과 같이 객체 생성 시 스레드로 실행할 함수를 요구한다.

```cpp
template <class F>
explicit packaged_task( F&& f )
```

promise 객체는 실행시킬 함수를 만들고 함수의 인수로 객체 자체를 전달하지만 packaged_task 객체는 객체 자체가 스레드로 실행되는 함수의 역할을 한다.

<br>

### 14 - 07 마무리

쓰레드로 실행되는 함수가 전역 변수에 순차적으로 접근시키는 방법은 다음 4가지가 존재한다. 주의할 사항으로 쓰레드 지역 변수와 함수 내부에서 사용하는 지역 변수는 동기화 과정 없이 안전하게 사용할 수 있다.

1. 쓰레드의 생성과 동시에 join() 함수를 호출하여 전역 변수의 접근을 순차적으로 만든다.
2. 전역 변수를 쓰레드별로 독립적으로 사용할 수 있는 쓰레드 지역 변수(Thread-Local Storage)를 사용한다.
3. 변수를 원자성 변수(Atomic variable)로 만든다.
4. 뮤텍스(Mutex)를 사용하여 인위적으로 전역 변수의 접근을 순차적으로 만든다.

<br>

뮤텍스를 가장 많이 사용하지만, 다른 방법을 고려해 보는 것도 좋다.

<br>

스레드로 수행된 함수의 작업 결과는 future 객체(또는 shared_future 객체)를 통해 받을 수 있다. 그러나 future 객체를 생성하는 방식에 따라 아래와 같은 방법들이 존재한다.

- async() 함수를 사용하여 future 객체를 반환 받는다면 함수가 반환하는 데이터를 get() 함수로 받게 된다.
- promise 객체를 사용한다면, future 객체는 get_future() 함수를 통해 생성되며, set_value() 함수를 통해 작업 결과를 get() 함수로 받게 된다.
- package_task 객체를 사용한다면, future 객체는 get_future() 함수를 통해 생성되며, 작업 결과는 get() 함수로 받게 된다.

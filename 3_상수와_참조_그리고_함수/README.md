# 상수와 참조 그리고 함수 03

- const 상수

변수 선언 시 데이터 타입 앞부분에 const 지정자를 사용한다면, 컴파일러는 해당 변수를 값이 변하지 않는 상수로 인식한다.

- constexpr 상수 표현식(Generalized constant expression)

C++11부터 constexpr 키워드로 상수 표현식을 제공한다. 다음과 같은 특징을 갖는다.

1. inline 함수처럼 매크로 형태로 실행된다.
2. 작업후 최종 결과는 상수가 된다.

```cpp
//상수 표현식은 일종의 inline 함수처럼 사용한다.
#include <iostream>
using namespace std;

constexpr unsigned long fibonacci(unsigned long i)
{
	return (i <= 1ul) ? i : (fibonacci(i - 1) + fibonacci(i - 2));
}

int main()
{
	// 아래 문장은 'unsigned long l = 610;'와 동일하게 처리된다.
	// 함수의 인수롤 상수를 입력하기 때문에 컴파일 시점에 상수로 인식된다.
	unsigned long i = fibonacci(15);
	cout << i << " = fibonacci(15)" << endl;
	return 0;
}
```

상수 표현식은 컴파일러가 컴파일 시점에 상수로 인식하는 것이다. (#define도 컴파일 시점에 결정)

→ const 상수는 프로그램이 실행되는 시점에 값이 결정된다.

### 3 - 03 상수표현식(constexpr)

상수표현식은 인라인 함수와 동일한 기능을 제공하지만, 추가적으로 일종의 메타프로그래밍처럼 상수표현식은 컴파일 단계에서 프로그래밍을 최적화하여 반환되는 값이 상수가 되는 식을 말한다. 즉, 우리는 프로그램으로 생각하여 코딩하지만, 컴파일러는 컴파일 작업 이후에 최종 바이너리 코드로 변환 시  상수표현식을 상수로 만든다.

constexpr 지정자는 다음과 같은 방법으로 선언한다.

1. constexpr 데이터타입 함수이름(인수)

```cpp
constexpr unsigned long fibonacci(unsigned long i)
{
	return (i <= 1) ? i : (fibonacci(i - 1) + fibonacci(i - 2));
}

int main()
{
	int num;
	cout << "i : ";
	cin >> num;
	
	//상수 표현식이라 하더라도 아래와 같이 일반 변수를 매개변수로 사용한다면, 
	//상수가 아닌 일반함수가 된다.
	//따라서 만약 'constexpr int res = fibonacci(num);'으로 표기하면 에러가 발생한다.
	int res = fibonacci(num);
	return 0;
}
```

constexpr 지정자를 사용하는 함수는 보통 재귀 함수(recursive function)에서 많이 사용한다.

1. “constexpr 데이터타입 상수이름 = 식” 또는 “constexpr 데이터타입 상수이름(식)”

```cpp
constexpr float x = 42.0;
constexpr float y{108};
constexpr int z = fibonacci(15); // fibonacci() 함수를 호출하여 결과값을 상수로 만든다.

int j = 0;
constexpr int k = j + 1; // j 변수는 const 지정자로 선언되어 있지 않아 에러가 된다.
```

요점정리

| constexpr 상수표현식 | const 상수 |
| --- | --- |
| 1. 상수표현식은 컴파일하는 시점부터 상수로 인식되는 식을 의미한다. | 1. const 상수는 프로그램이 실행되는 시점에 상수로 인식된다. |
| 2. 상수표현식은 함수보다 빠른 성능을 보장한다. | 2. const 상수는 안전성을 확보하기 위해 사용한다. |
| 3. 상수표현식은 일반 변수부터 시작하여 함수와 클래스의 생성자까지 사용이 가능하다. | 3. const 지정자는 식이 아닌 변수와 함께 사용되어 상수로 인식하게 된다. 또 다른 사용 방법으로 다음과 같이 본문에 적용하여 클래스 내부 멤버 변수의 수정을 금지하는 기능을 제공한다. |
| - 상수표현식이 변수에 적용한다면, 상수를 의미한다.                                                                                          - 상수표현식이 함수에 적용한다면, 함수는 리터럴을 반환하는 것으로 인식한다.                                                   - 상수표현식이 생성자에 적용한다면, 모든 멤버 변수는 초기화되어 있는 상수로 인식한다. | constexpr std::size_t size() const { return sz; } |

### 3 - 04 참조(Reference)

다형성을 지원하기 위해 만든 가상 변수

ex) 자바

- 기본 타입의 변수는 선언과 동시에 스택 메모리 내 저장소를 잡는다.
- 클래스 타입의 변수는 오로지 힙 메모리 내 저장소를 잡는다.
- 모든 객체(또는 클래스의 인스턴스)는 스택이 아닌 힙 메모리 공간에 저장소를 잡는다. 변수는 해당 객체를 가리킨다.

ex) C, C++

- 기본 타입이든 구조체이든 상관없이 변수 선언 시 스택 메모리 내 저장소를 잡는다.
- 또한 new, malloc() 함수와 연결되는 포인터는 기본 타입의 변수 또는 구조체의 변수와 관계없이 힙 메모리 주소에 저장소를 잡는다.

**C++ 언어는 객체 지향의 기본 원칙을 지원하기 위해 변수와 포인터가 아닌 세 번째 데이터 타입으로 참조를 만들게 되었다.** 즉, 참조는 용어 그대로 객체 지향 언어에서 제공하는 가상 테이블과 가상 포인터를 사용할 수 있도록 만들어진 가상의 변수이다.

```cpp
class Student { ... }

Student* s = new Student(); //new 지시어를 사용하여 객체를 생성하고 포인터로 연결한다.
Student& ss = *s; //포인터가 가리키는 저장소를 참조로 만든다.

delete s; //s 변수의 저장소를 운영체제에 반납한다.
```

l-value

내가 알고 있는 지식 : 메모리에 할당된 값

l-value 참조를 만든 주요 목적

1. 객체 지향의 개념 지원

내가 알고 있는 지식 : 이는 다형성의 개념에서 나타나는데 예를 들어 하위 클래스로 상위 클래스를 가리키는 다운 캐스팅에 대해 생각해볼 때, 상위 클래스는 하위 클래스의 정보를 알고 있지 않기 때문에 참조나 포인터를 사용해 캐스팅하지 않을 경우 캐스팅시 에러가 발생하게 된다.

1. 프로그램의 성능 향상

pass-by-reference t